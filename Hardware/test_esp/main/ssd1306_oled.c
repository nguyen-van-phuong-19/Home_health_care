/**
 * @file ssd1306_oled.c
 * @brief SSD1306 OLED display driver implementation.
 *
 * This source file contains the implementation of functions to control a 128x64 SSD1306 OLED display 
 * over I2C using the ESP-IDF. It uses an internal 1024-byte buffer (128x64 pixels, divided into 8 pages of 8 pixels each).
 */

#include "ssd1306_oled.h"
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// Control byte values for I2C communication (SSD1306)
#define SSD1306_CONTROL_BYTE_CMD  0x00  /**< Control byte indicating a command is being sent (D/C# = 0) */
#define SSD1306_CONTROL_BYTE_DATA 0x40  /**< Control byte indicating data is being sent (D/C# = 1) */

// Internal buffer to store screen data before sending to OLED (1 byte per column per page)
static uint8_t ssd1306_buffer[SSD1306_BUFFER_SIZE];

// Forward declaration of internal helper functions
static esp_err_t ssd1306_send_cmd(uint8_t cmd);
static esp_err_t ssd1306_send_data(const uint8_t *data, size_t length);

// 5x7 font definition (classic ASCII characters 0x20-0x7E)
// Each character is 5 bytes (5 columns of 8 pixels). Bit 0 of each byte is the top row of the character.
static const uint8_t ssd1306_font5x7[] = {
    // ASCII 0x20 (Space) to 0x7F (DEL)
    0x00,0x00,0x00,0x00,0x00,  // 0x20 ' ' 
    0x00,0x00,0x5F,0x00,0x00,  // 0x21 '!' 
    0x00,0x07,0x00,0x07,0x00,  // 0x22 '"'
    0x14,0x7F,0x14,0x7F,0x14,  // 0x23 '#'
    0x24,0x2A,0x6B,0x2A,0x12,  // 0x24 '$'
    0x63,0x13,0x08,0x64,0x63,  // 0x25 '%'
    0x36,0x49,0x56,0x20,0x50,  // 0x26 '&'
    0x00,0x00,0x07,0x00,0x00,  // 0x27 '''
    0x00,0x3C,0x42,0x81,0x00,  // 0x28 '('
    0x00,0x81,0x42,0x3C,0x00,  // 0x29 ')'
    0x14,0x08,0x3E,0x08,0x14,  // 0x2A '*'
    0x08,0x08,0x3E,0x08,0x08,  // 0x2B '+'
    0x00,0x80,0x60,0x00,0x00,  // 0x2C ','
    0x08,0x08,0x08,0x08,0x08,  // 0x2D '-'
    0x00,0x00,0x60,0x00,0x00,  // 0x2E '.'
    0x20,0x10,0x08,0x04,0x02,  // 0x2F '/'
    0x3E,0x51,0x49,0x45,0x3E,  // 0x30 '0'
    0x00,0x42,0x7F,0x40,0x00,  // 0x31 '1'
    0x42,0x61,0x51,0x49,0x46,  // 0x32 '2'
    0x21,0x41,0x45,0x4B,0x31,  // 0x33 '3'
    0x18,0x14,0x12,0x7F,0x10,  // 0x34 '4'
    0x27,0x45,0x45,0x45,0x39,  // 0x35 '5'
    0x3C,0x4A,0x49,0x49,0x30,  // 0x36 '6'
    0x01,0x71,0x09,0x05,0x03,  // 0x37 '7'
    0x36,0x49,0x49,0x49,0x36,  // 0x38 '8'
    0x06,0x49,0x49,0x29,0x1E,  // 0x39 '9'
    0x00,0x00,0x6C,0x00,0x00,  // 0x3A ':'
    0x00,0x80,0x6C,0x00,0x00,  // 0x3B ';'
    0x08,0x14,0x22,0x41,0x00,  // 0x3C '<'
    0x24,0x24,0x24,0x24,0x24,  // 0x3D '='
    0x00,0x41,0x22,0x14,0x08,  // 0x3E '>'
    0x02,0x01,0x51,0x09,0x06,  // 0x3F '?'
    0x3E,0x41,0x5D,0x59,0x4E,  // 0x40 '@'
    0x7C,0x12,0x11,0x12,0x7C,  // 0x41 'A'
    0x7F,0x49,0x49,0x49,0x36,  // 0x42 'B'
    0x3E,0x41,0x41,0x41,0x22,  // 0x43 'C'
    0x7F,0x41,0x41,0x22,0x1C,  // 0x44 'D'
    0x7F,0x49,0x49,0x49,0x41,  // 0x45 'E'
    0x7F,0x09,0x09,0x09,0x01,  // 0x46 'F'
    0x3E,0x41,0x49,0x49,0x7A,  // 0x47 'G'
    0x7F,0x08,0x08,0x08,0x7F,  // 0x48 'H'
    0x00,0x41,0x7F,0x41,0x00,  // 0x49 'I'
    0x20,0x40,0x41,0x3F,0x01,  // 0x4A 'J'
    0x7F,0x08,0x14,0x22,0x41,  // 0x4B 'K'
    0x7F,0x40,0x40,0x40,0x40,  // 0x4C 'L'
    0x7F,0x02,0x0C,0x02,0x7F,  // 0x4D 'M'
    0x7F,0x04,0x08,0x10,0x7F,  // 0x4E 'N'
    0x3E,0x41,0x41,0x41,0x3E,  // 0x4F 'O'
    0x7F,0x09,0x09,0x09,0x06,  // 0x50 'P'
    0x3E,0x41,0x51,0x21,0x5E,  // 0x51 'Q'
    0x7F,0x09,0x19,0x29,0x46,  // 0x52 'R'
    0x46,0x49,0x49,0x49,0x31,  // 0x53 'S'
    0x01,0x01,0x7F,0x01,0x01,  // 0x54 'T'
    0x3F,0x40,0x40,0x40,0x3F,  // 0x55 'U'
    0x1F,0x20,0x40,0x20,0x1F,  // 0x56 'V'
    0x7F,0x20,0x18,0x20,0x7F,  // 0x57 'W'
    0x63,0x14,0x08,0x14,0x63,  // 0x58 'X'
    0x03,0x04,0x78,0x04,0x03,  // 0x59 'Y'
    0x61,0x51,0x49,0x45,0x43,  // 0x5A 'Z'
    0x00,0x7F,0x41,0x41,0x00,  // 0x5B '['
    0x02,0x04,0x08,0x10,0x20,  // 0x5C '\\'
    0x00,0x41,0x41,0x7F,0x00,  // 0x5D ']'
    0x04,0x02,0x01,0x02,0x04,  // 0x5E '^'
    0x80,0x80,0x80,0x80,0x80,  // 0x5F '_'
    0x00,0x03,0x07,0x08,0x00,  // 0x60 '`' (deg symbol or accent)
    0x20,0x54,0x54,0x54,0x78,  // 0x61 'a'
    0x7F,0x48,0x44,0x44,0x38,  // 0x62 'b'
    0x38,0x44,0x44,0x44,0x20,  // 0x63 'c'
    0x38,0x44,0x44,0x48,0x7F,  // 0x64 'd'
    0x38,0x54,0x54,0x54,0x18,  // 0x65 'e'
    0x08,0x7E,0x09,0x01,0x02,  // 0x66 'f'
    0x0C,0x52,0x52,0x52,0x3E,  // 0x67 'g'
    0x7F,0x08,0x04,0x04,0x78,  // 0x68 'h'
    0x00,0x44,0x7D,0x40,0x00,  // 0x69 'i'
    0x20,0x40,0x44,0x3D,0x00,  // 0x6A 'j'
    0x7F,0x10,0x28,0x44,0x00,  // 0x6B 'k'
    0x00,0x41,0x7F,0x40,0x00,  // 0x6C 'l'
    0x7C,0x04,0x18,0x04,0x7C,  // 0x6D 'm'
    0x7C,0x08,0x04,0x04,0x78,  // 0x6E 'n'
    0x38,0x44,0x44,0x44,0x38,  // 0x6F 'o'
    0x7C,0x14,0x14,0x14,0x08,  // 0x70 'p'
    0x08,0x14,0x14,0x18,0x7C,  // 0x71 'q'
    0x7C,0x08,0x04,0x04,0x08,  // 0x72 'r'
    0x48,0x54,0x54,0x54,0x20,  // 0x73 's'
    0x04,0x3F,0x44,0x40,0x20,  // 0x74 't'
    0x3C,0x40,0x40,0x20,0x7C,  // 0x75 'u'
    0x1C,0x20,0x40,0x20,0x1C,  // 0x76 'v'
    0x3C,0x40,0x30,0x40,0x3C,  // 0x77 'w'
    0x44,0x28,0x10,0x28,0x44,  // 0x78 'x'
    0x0C,0x10,0x50,0x20,0x1C,  // 0x79 'y'
    0x44,0x64,0x54,0x4C,0x44,  // 0x7A 'z'
    0x00,0x08,0x76,0x81,0x81,  // 0x7B '{'
    0x00,0x00,0xFF,0x00,0x00,  // 0x7C '|' 
    0x81,0x81,0x76,0x08,0x00,  // 0x7D '}'
    0x08,0x04,0x08,0x10,0x08,  // 0x7E '~' (arrow symbol)
    0x55,0x2A,0x55,0x2A,0x55   // 0x7F 'DEL' (checkerboard pattern)
};

void ssd1306_init(void) {
    // Initialize I2C master for SSD1306
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = SSD1306_I2C_SDA_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_io_num = SSD1306_I2C_SCL_PIN,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = SSD1306_I2C_FREQ_HZ,
        // .clk_flags = 0, // optional: use 0 for default
    };
    i2c_param_config(SSD1306_I2C_PORT, &conf);
    i2c_driver_install(SSD1306_I2C_PORT, conf.mode, 0, 0, 0);

    // Clear buffer
    ssd1306_clear();

    // Send initialization commands to SSD1306
    ssd1306_send_cmd(0xAE); // Display off :contentReference[oaicite:4]{index=4}
    ssd1306_send_cmd(0xD5); // Set display clock divide ratio/oscillator frequency
    ssd1306_send_cmd(0x80); // Suggested oscillator frequency (0x80):contentReference[oaicite:5]{index=5}
    ssd1306_send_cmd(0xA8); // Set multiplex ratio
    ssd1306_send_cmd(0x3F); // 1/64 duty (64-1) :contentReference[oaicite:6]{index=6}
    ssd1306_send_cmd(0xD3); // Set display offset
    ssd1306_send_cmd(0x00); // No offset
    ssd1306_send_cmd(0x40); // Set start line address (0)
    ssd1306_send_cmd(0x8D); // Enable charge pump regulator
    ssd1306_send_cmd(0x14); // Enable internal DC/DC (charge pump):contentReference[oaicite:7]{index=7}
    ssd1306_send_cmd(0x20); // Set Memory Addressing Mode
    ssd1306_send_cmd(0x02); // Page addressing mode (0x00 for horizontal):contentReference[oaicite:8]{index=8}
    ssd1306_send_cmd(0xA1); // Set segment re-map (column address 127 mapped to SEG0):contentReference[oaicite:9]{index=9}
    ssd1306_send_cmd(0xC8); // Set COM output scan direction (remapped mode):contentReference[oaicite:10]{index=10}
    ssd1306_send_cmd(0xDA); // Set COM pins hardware configuration
    ssd1306_send_cmd(0x12); // Alternative COM pin config, disable left/right remap:contentReference[oaicite:11]{index=11}
    ssd1306_send_cmd(0x81); // Set contrast control
    ssd1306_send_cmd(0xCF); // Set contrast to 0xCF (high contrast):contentReference[oaicite:12]{index=12}
    ssd1306_send_cmd(0xD9); // Set pre-charge period
    ssd1306_send_cmd(0xF1); // Phase 1: 15 DCLK, Phase 2: 1 DCLK:contentReference[oaicite:13]{index=13}
    ssd1306_send_cmd(0xDB); // Set VCOMH deselect level
    ssd1306_send_cmd(0x40); // VCOMH deselect ~0.77 x VCC:contentReference[oaicite:14]{index=14}
    ssd1306_send_cmd(0xA4); // Entire display ON (resume RAM content):contentReference[oaicite:15]{index=15}
    ssd1306_send_cmd(0xA6); // Set normal display (0xA7 for inverse):contentReference[oaicite:16]{index=16}
    ssd1306_send_cmd(0xAF); // Display ON in normal mode:contentReference[oaicite:17]{index=17}
}

void ssd1306_clear(void) {
    // Set entire buffer to 0 (cleared/off pixels)
    for (size_t i = 0; i < SSD1306_BUFFER_SIZE; ++i) {
        ssd1306_buffer[i] = 0x00;
    }
}

void ssd1306_draw_char(uint8_t x, uint8_t page, char c) {
    if (page >= SSD1306_PAGE_COUNT || x >= SSD1306_WIDTH) {
        return; // out of bounds, do nothing
    }
    if ((uint8_t)c < 0x20 || (uint8_t)c > 0x7F) {
        // If character not in font range, replace with space
        c = ' ';
    }
    uint16_t index = (uint8_t)(c - 0x20) * 5;
    uint16_t buffer_index = page * SSD1306_WIDTH + x;
    // Copy character font pattern into the buffer
    for (int i = 0; i < 5; ++i) {
        if (x + i >= SSD1306_WIDTH) break;  // stop if beyond display width
        ssd1306_buffer[buffer_index + i] = ssd1306_font5x7[index + i];
    }
    // Add one column of spacing (blank column) after the character, if it fits
    if (x + 5 < SSD1306_WIDTH) {
        ssd1306_buffer[buffer_index + 5] = 0x00;
    }
}

void ssd1306_draw_string(uint8_t x, uint8_t page, const char *str) {
    uint8_t pos = x;
    while (*str != '\0') {
        ssd1306_draw_char(pos, page, *str++);
        // Advance cursor by 6 (5-pixel character + 1-pixel space)
        if (pos + 6 < SSD1306_WIDTH) {
            pos += 6;
        } else {
            // No more space on this line
            break;
        }
    }
}

void ssd1306_refresh(void) {
    // Write the internal buffer to the OLED display, page by page
    for (uint8_t page = 0; page < SSD1306_PAGE_COUNT; ++page) {
        // Set the current page number and reset column address to 0
        ssd1306_send_cmd(0xB0 | page);    // Set page start address (B0h+B)
        ssd1306_send_cmd(0x00);           // Set lower column address to 0
        ssd1306_send_cmd(0x10);           // Set higher column address to 0
        // Send 128 bytes of display data for this page
        ssd1306_send_data(&ssd1306_buffer[page * SSD1306_WIDTH], SSD1306_WIDTH);
    }
}

// Internal function to send a single command byte to the SSD1306 over I2C
static esp_err_t ssd1306_send_cmd(uint8_t cmd) {
    i2c_cmd_handle_t cmd_handle = i2c_cmd_link_create();
    // Start I2C communication
    i2c_master_start(cmd_handle);
    // Send the device address (with write bit)
    i2c_master_write_byte(cmd_handle, (SSD1306_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    // Send control byte indicating a command
    i2c_master_write_byte(cmd_handle, SSD1306_CONTROL_BYTE_CMD, true);
    // Send the command byte
    i2c_master_write_byte(cmd_handle, cmd, true);
    // Finish the I2C transaction
    i2c_master_stop(cmd_handle);
    esp_err_t err = i2c_master_cmd_begin(SSD1306_I2C_PORT, cmd_handle, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd_handle);
    return err;
}

// Internal function to send a data buffer to the SSD1306 over I2C
static esp_err_t ssd1306_send_data(const uint8_t *data, size_t length) {
    i2c_cmd_handle_t cmd_handle = i2c_cmd_link_create();
    // Start I2C communication
    i2c_master_start(cmd_handle);
    i2c_master_write_byte(cmd_handle, (SSD1306_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    // Send control byte indicating a data stream
    i2c_master_write_byte(cmd_handle, SSD1306_CONTROL_BYTE_DATA, true);
    // Write the data bytes
    i2c_master_write(cmd_handle, data, length, true);
    // Finish the I2C transaction
    i2c_master_stop(cmd_handle);
    esp_err_t err = i2c_master_cmd_begin(SSD1306_I2C_PORT, cmd_handle, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd_handle);
    return err;
}
